---
layout: post
title: "【Java虚拟机系列】三、Java虚拟机之垃圾回收"
subtitle: 'Java虚拟机原理学习'
date:       2018-04-05
author: "Wangxiong"
header-style: text
tags:
  - Java
  - JVM
---
## 1.GC(垃圾收集器)概述

GC主要有两个工作：内存的划分和分配，进行垃圾回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖GC的设计的。关于垃圾回收，被引用的对象是存活的对象，不被引用的对象是垃圾对象，GC要区分出存活的对象和死亡的对象，也就是垃圾标记，并对垃圾进行回收。

## 2.垃圾标记算法

目前有两种垃圾标记算法，分别是引用计数算法和根搜索算法，这两种算法都和引用有些联系，先回顾下引用的知识。

### 2.1引用

JDK1.2之后，Java将引用分为强引用、弱引用、软引用和虚引用。

- 强引用：当我们new一个对象时就是创建了一个具有强引用的对象，如果一个对象具有强引用，垃圾收集器就绝不会回收它。Java虚拟机宁愿抛出OutOfMemoryError异常，使程序异常终止，也不会回收具有强引用的对象来解决内存不足的问题。
- 软引用：如果一个对象只具有软引用，当内存不够时，会回收这些对象的内存，回收后如果还是没有足够的内存，就会抛出OutOfMemoryError异常。Java提供了SoftReference类来实现软引用。
- 弱引用：弱引用比起软引用具有更短的生命周期，垃圾收集器一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存。Java提供了WeakReference类来实现弱引用。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，这就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。一个只具有虚引用的对象，被垃圾收集器回收时会收到一个系统通知，这也是虚引用的主要作用。Java提供了PhantomReference类来实现虚引用。

### 2.2 引用计数算法

引用计数算法的基本思想就是每个对象都有一个引用计数器，当对象在某处被引用的时候，它的引用计数器就加1，引用失效时就减1。当引用计数器中的值变为0，则该对象就不能被使用成了垃圾。

目前主流的Java虚拟机没有选择引用计算算法来标记垃圾，主要原因是引用计算算法无法解决对象之间互相循环引用的问题。

### 2.3 根搜索算法

根搜索算法的基本思想是选的一些对象作为GC Roots，并组成根对象集合，然后从这些GC Roots的对象作为起始点，向下进行搜索，如果目标对象到GC Roots是连接着的，则标记该对象是可达的，如果目标对象是不可达的，则说明对象是可回收的垃圾对象。

可作为GC Roots的对象有以下几种：

Java虚拟机栈中的引用的对象。

本地方法栈中JNI引用的对象。

方法区中运行时常量池引用的对象。

运行中的线程。

由引导类加载器加载的对象

GC控制的对象。

## 3. 垃圾收集算法

利用垃圾标记算法，标记垃圾之后，GC会对垃圾进行收集，垃圾收集算法有很多种，常用的如下

### 3.1 标记-清除算法

标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：

- 标记阶段：标记出可以回收的对象。
- 清除阶段：回收被标记的对象所占用的空间。

标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。标记-清除算法的执行的过程如下图所示。
[![标记清除算法(1)_副本.png](http://upload-images.jianshu.io/upload_images/1417629-640f81274f7af6a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

标记-清除算法主要有两个缺点，一个是标记和清除的效率都不高，另一个从上图就可以看出来，就是容易产生大量不连续的内存碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前触发新的一次垃圾收集动作。

### 3.2 复制算法

为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。复制算法的执行过程如下图所示。

[![复制算法_副本.png](http://upload-images.jianshu.io/upload_images/1417629-45794a3feeb58bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这种算法每次都对整个半区进行内存回收，不需要考虑内存碎片的问题，代价就是使用内存为原来的一半。
复制算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很少，复制算法的效率就会很高。由于绝大多数对象的生命周期很短，并且这些生命周期很短的对象都存于新生代中，所以复制算法被广泛应用于新生代中，关于新生代中复制算法的应用，会在后面的分代收集算法中详细介绍。

### 3.3 标记-压缩算法

在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-压缩算法（Mark-Compact）算法，与标记-清除算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边，如下图所示。

[![标记压缩算法_副本.png](http://upload-images.jianshu.io/upload_images/1417629-66221a170d6869d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

标记-压缩算法解决了标记-清除算法效率低和容易产生大量内存碎片的问题，它被广泛的应用于老年代中。

### 3.4 分代收集算法

**Java堆区的空间划分**

在Java虚拟机中，各种对象的生命周期会有着较大的差别，大部分对象生命周期很短暂，少部分对象生命周期很长，有的甚至和应用程序以及Java虚拟机的运行周期一样长。因此，应该对不同生命周期的对象采取不同的收集策略，根据生命周期长短将它们分别放到不同的区域，并在不同的区域采用不同的收集算法，这就是分代的概念。
现在主流的Java虚拟机的垃圾收集器都采用分代收集算法（Generational Collection）。Java堆区基于分代的概念，分为新生代（Young Generation）和老年代（Tenured Generation），其中新生代再细分为Eden空间、From Survivor空间和To Survivor空间。因为Eden空间大多对象生命周期很短，所以新生代的空间划分并不是均分的，HotSpot虚拟机默认Eden空间和两个Survivor空间的所占的比例为8：1。

**分代收集**

根据Java堆区的空间划分，垃圾收集的类型分为两种，它们分别是：

- Minor Collection：新生代垃圾收集。
- Full Collection：对新生代、老年代和永久代（JDK8 取消永久代，Full Collection扫描不到替代永久代的元空间）进行收集，又可以称作Majjor Collection。它的收集频率较低，耗时较长。

当执行一次Minor Collection时，Eden空间的存活对象会被复制到To Survivor空间，并且之前经过一次Minor Collection并在From Survivor空间存活的仍年轻的对象也会复制到To Survivor空间。
有两种情况Eden空间和From Survivor空间存活的对象不会复制到To Survivor空间，而是晋升到老年代。一种是存活的对象的分代年龄超过-XX:MaxTenuringThreshold（用于控制对象经历多少次Minor GC才晋升到老年代）所指定的阈值。另一种是To Survivor空间容量达到阈值。
当所有存活的对象被复制到To Survivor空间，或者晋升到老年代，也就意味着Eden空间和From Survivor空间剩下的都是可回收对象，如下图所示。
![GC执行前(1).png](http://upload-images.jianshu.io/upload_images/1417629-03a21b8d9934c2a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这时GC执行Minor Collection，Eden空间和From Survivor空间都会被清空，而存活的对象都存放在To Survivor空间。
接下来将From Survivor空间和To Survivor空间互换位置，也就是此前的From Survivor空间成为了现在的To Survivor空间，每次Survivor空间互换都要保证To Survivor空间是空的，这就是复制算法在新生代中的应用。在老年代则采用了标记-压缩算法。
在HotSpot中，基于分代的概念，GC使用的回收算法针对新生代和老年代的特点，采用不同的垃圾收集算法。

## 4.Java对象在JVM中的生命周期

当Java对象被类加载器加载到虚拟机中后，Java对象在Java虚拟机中有7个阶段。

### 4.1.创建阶段(Created)

创建阶段的具体步骤为：

- 为对象分配存储空间。
- 构造对象。
- 从超类到子类对static成员进行初始化。
- 递归调用超类的构造方法。
- 调用子类的构造方法。

### 4.2.应用阶段(In Use)

当对象被创建，并分配给变量赋值，状态就切换到了应用阶段。
这一阶段的对象至少要具有一个强引用，或者显式的使用软引用、弱引用或者虚引用。

### 4.3.不可见阶段(Invisible)

程序中找不到对象的任何强引用，比如程序的执行已经超出了该对象的作用域。在不可见阶段，对象仍可能被特殊的强引用GC Roots持有着，比如对象被本地方法栈中JNI引用或是被运行中的线程引用等。

### 4.4.不可达阶段(Unreachable)

程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达。

### 4.5.收集阶段(Collected)

垃圾收集器已经发现对象不可达，并且垃圾收集器已经准备好要对该对象的内存空间重新进行分配时。这个时候如果该对象重写了finalize方法，则会调用该方法。

### 4.6.终结阶段(Finalized)

当对象执行完finalize法后仍然处于不可达状态时，或者对象没有重写finalize方法，则该对象进入终结阶段，并等待垃圾收集器回收该对象空间。

### 4.7.对象空间重新分配阶段(Deallocated)

当垃圾收集器对对象的内存空间进行回收或者再分配时，这个对象就会彻底消失。



