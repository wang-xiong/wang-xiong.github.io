## 1. Lru

最近最少使用算法， 如果数据最近被访问过，那么将来访问的概率也很高。使用的是链表来缓存数据。

### 1.1 原理：

- 1.新插入的数据放在链表头
- 2.每当缓存命中，则移动数据到头部。
- 3.当链表满时，将链表尾部的数据丢弃

### 1.2 命中率

当存在数据热点时，效率好，但是偶发的，周期性的批量操作会导致LRU命中率急剧下降，缓存污染比较严重。

### 1.3 命中

命中时需要遍历链表，找到数据块索引，然后将数据移动到头部。

## 3. LRU-K

相比LRU，LRU-K需要维护一个队列，用于缓存数据被访问的历史，只有当数据访问到K次时，才会将数据放在缓存中，当需要淘汰数据时，淘汰缓存队列最后的数据，缓存队列按照时间排序。

### 3.1 原理

- 1.数据第一次访问，加到访问历史列表里。
- 2.如果数据在访问历史列表里访问次数没有达到K次，则按照一定规则（FIFO,LRU）淘汰。
- 3.当访问历史列表次数达到K次，将数据从历史列表中删除，将数据添加到缓存队列中，并缓存数据，缓存队列重新按时间排序。
- 4.缓存数据队列被再次访问后，重新排序；
- 5.需要淘汰数据时，淘汰缓存队列中末尾的数据。

### 3.2 命中率

LRU-K降低了缓存污染的问题，命中率比LRU高

### 3.3 复杂度

LRU-K队列是一个优先级队列，算法复杂度和代价比较高

### 3.4 代价

由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。