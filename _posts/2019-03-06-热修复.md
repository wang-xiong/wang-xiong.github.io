---
layout: post
title: "热修复"
subtitle: 'Android'
date:       2019-03-06
author: "Wangxiong"
header-style: text
tags:
  - Android
---

热修复

热修复框架：AndFix、Tinker、Dexposed、Nuwa

| 类别     | 成员                                             |
| -------- | :----------------------------------------------- |
| 阿里系   | AndFix、Dexposed、Sophix                         |
| 腾讯系   | 微信的Tinker、QQ空间的超级补丁、手机QQ的QFix     |
| 知名公司 | 美团的Robust、饿了么的Amigo、美丽说蘑菇街的Aceso |
| 其他     | RocooFix、Nuwa、AnoleFix                         |

部分热修复架构的对比

| 特性           | AndFix | Tinker/Amigo | QQ空间 | Robust/Aceso |
| -------------- | ------ | ------------ | ------ | ------------ |
| 即时生效       | 是     | 否           | 否     | 是           |
| 方法替换       | 是     | 是           | 是     | 是           |
| 类替换         | 否     | 是           | 是     | 否           |
| 类结构修改     | 否     | 是           | 否     | 否           |
| 资源替换       | 否     | 是           | 是     | 否           |
| so替换         | 否     | 是           | 否     | 否           |
| 支持gradle     | 否     | 是           | 否     | 否           |
| 支持ART        | 是     | 是           | 是     | 是           |
| 支持Android7.0 | 是     | 是           | 是     | 是           |

代码修复

代码修复主要有三个方案：底层替换方案、类加载方案、Instant Run方案。

### 1.类加载方案：

（1）类加载方案是基于Dex分包方案，当应用中引用的方法数超过最大数65536个编译会报错，解决的方法是Dex分包方案，Dex分包方案主要是在打包的时候将应用的代码分成多个Dex，将应用启动时必须要用到的类和这些类的直接引用类放到主Dex中，其他代码放到次Dex中。当应用启动时先加载主Dex，等应用启动后再动态加载次Dex。Dex分包方案主要有两种：Google官方的方案、Dex自动拆包和动态加载方案。

（2）类加载方案首先要理解ClassLoader的加载过程，其中重要的一个环节就是调用DexPathList的findClass方法。Element内部封装了DexFile，DexFile用于加载Dex文件，每个dex文件对应一个Element。对个Element组成了有序的Element数组dexElements。当查找类时会遍历dexElements，调用Element的findClass方法，其内部调用了DexFile的loadClassBinaryName方法查找类，如果找到直接返回，没有找到继续在下个Element进行查找。

（3）根据上边的流程，可以将有bug的类进行修改，打包成新的bug.dex放在dexElements的第一个元素，这样就会替换目标bug类。

（4）类加载方案需要重启App后让ClassLoader重新加载类，所以采用类加载修复的框架是不能即时生效的。

**采用类加载方案的代码修复框架：**

- QQ空间的超级补丁：修改故障类产生path.dex，将path.dex放在Element的第一个元素。
- Nuwa：修改故障类产生path.dex，将path.dex放在Element的第一个元素。
- Tinker：将新旧的APK做diff，得到patch.dex，然后将path.dex与apk中的classes.dex做合并，生成新的classes.dex，然后在运行时通过反射将新的classes.dex放在Element数字的第一个元素。
- Amigo：将补丁包中每个dex对应的Element取出来，之后组成新的Element数组，在运行时通过反射用新的Element数组替换掉现有的Element数组。

### 2.底层替换方案

底层替换方案不会加载新的类，而是直接在Native层修改原有的类，修改原有的类限制会比较多，不能增减原有类的方法和字段，如果我们增加了方法数，那么方法索引也会增加，这样访问方法时会无法通过索引找到正确的方法，字段也是如此。

一个Native方法在ART虚拟机中对应一个ArtMethod指针，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口，访问权限，所属类和代码执行地址等，替换ArtMethod结构体的字段或者替换整个ArtMethod结构体，就是底层替换方案。底层替换方案直接替换了方法，可以立即生效不需要重启。

**采用底层替换方案的修复框架**

AndFix：采用的是替换ArtMethod的结构体中的字段，这样会有兼容问题，因为厂商可能修复ArtMethod结构体，导致方法替换失败。支持dalvik和art

Sophix：采用的是替换整个结构体，不会有兼容问题。

Deposed：采用的是替换整个结构体，支持dalvik不支持art

HotFix

### 3.Instant Run方案

**采用Instant Run方案的修复框架**

Robust：对每个产品的代码的每个函数在编译打包阶段自动插入一段代码，插入过程对业务开发完全透明

编译打包阶段自动为每个class都增加了一个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。

Aceso





Total control电脑连接手机模拟器

AndFix

Tinker

javac将java编译成class，da.bat将class打包成dex

classes.dex(主包5)

classes2.dex(bug包)

.....

增量更新：差分补丁

热修复：修复线上bug

插件化：拓展功能

思路：将我们修复好的classes2.dex下载到本机，并替换有bug的dex文件

1.创建BaseDexClassLoader子类DexClassLoader加载器

2.加载修复好的classes2.dex(从服务端下载好的修复包)

3.将自己的dex和系统的dexElements进行合并生成自己的dexElemnents，并且设置dexElemnents的优先级(自己的dex插到最前边)

4.通过反射技术，赋值给系统BaseDexClassLoader的pathList

新的dexElemnents：classes2.dex(修复包)、classes.dex、classes2.dex(bug包)、...

multidex配置

1.从服务端下载修复包

2.复制修复包到app的私有目录(源文件，目标目录和文件，删除之前存在的dex)

3.开始修复：

过程：请求接口下载修复的dex文件，如3.3版本请求接口，发下有修复故障的dex文件，则下载

```java
class BaseDexClassLoader extends ClassLoader {
    private final DexPathList pathList;
    
    //...
    
    
    findClass() {
        pathList.findClass()
    }
}
```

```java
class DexPathList  {
    Element[] dexElements;//classes.dex, classes2.dex，...
}
```

注意事项：

1.主包classes.dex不能有bug

2.必须是运行

类加载器：ClassLoader

子类：BaseDexClassLoader

一般下载的apk放在sdcard/download目录下

app安装成功，同时复制一份apk文件到私有目录：data/app/packageName-1/base.apk