---
layout: post
title: "「Java并发编程」Volatile关键字"
subtitle: 'Java基础回顾复习'
date:       2018-03-27
author: "Wangxiong"
header-style: text
tags:
  - Java
---
## 1. Java内存模型

Java内存模型规定所以的变量都是存在主存中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。每行线程不能访问其他线程的工作内存。

```java
int a =1；
```

上述代码的执行过程：执行线程先在自己的工作线程对变量a所在的缓存进行赋值，然后再将值写入主存中。

## 2. 原子性

对基本数据的读取和赋值操作(数字赋值给变量，变量赋值给变量不是原子操作)都是原子性操作，即这些操作不可被中断，要么执行，要么不执行。

```java
x = 10;        //原子操作，基本数据的赋值
y = x;         //非原子操作，读取主存x的值，x值写入工作内存是一个原子操作，将x赋值给爷y也是一个原子操作
x++;           //读取x值，+1操作，写入x的值，三个原子操作
x = x + 1;     //读取x值，+1操作，写入x的值，三个原子操作
```

## 3. 可见性

可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是不可见的，普通的共享变量不能保证可见性。但是使用volatile修饰变量时，它会保证修改的值立即被更新到主存，对其他线程是可见，其他线程读取时会直接读取主存的新值。

## 4. 有序性

在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 

可以通过volatile关键字来保证一定的“有序性”。另外synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，所以synchronized和Lock也可以保证有序性。

## 5. volatile关键字

使用volatile修饰共享变量，可以保证不同线程之间对这个变量进行操作时的可见性，即某个线程修改了变量，其他线程立即可见的。但是只有线程在修改变量时，其他线程的工作内存中的缓存才会失效，直接读取主存。但是volatile不保证原子性，即对变量的读取不会保证其他线程工作线程缓存失效。比如多个线程进行自增操作不是原子操作，在读取的时候线程可能都会读写到同一个值。

## 6. 正确使用volatile

synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：对变量的写操作不依赖于当前值；该变量没有包含在具有其他变量的不变式中。

**常用的使用场景：**状态标记，单例模式的双重检查。

