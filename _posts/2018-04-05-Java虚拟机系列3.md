---
layout: post
title: "【Java虚拟机系列】三、Java虚拟机之垃圾回收"
subtitle: 'Java虚拟机原理学习'
date:       2018-04-05
author: "Wangxiong"
header-style: text
tags:
  - Java
  - JVM
---
## 1.GC(垃圾收集器)概述

GC主要有两个工作：内存的划分和分配，进行垃圾回收。关于内存的划分和分配，目前Java虚拟机内存的划分是依赖GC的设计的。关于垃圾回收，被引用的对象是存活的对象，不被引用的对象是垃圾对象，GC要区分出存活的对象和死亡的对象，也就是垃圾标记，并对垃圾进行回收。

## 2.垃圾标记算法

目前有两种垃圾标记算法，分别是引用计数算法和根搜索算法，这两种算法都和引用有些联系，先回顾下引用的知识。

### 2.1引用

JDK1.2之后，Java将引用分为强引用、弱引用、软引用和虚引用。

- 强引用：当我们new一个对象时就是创建了一个具有强引用的对象，如果一个对象具有强引用，垃圾收集器就绝不会回收它。Java虚拟机宁愿抛出OutOfMemoryError异常，使程序异常终止，也不会回收具有强引用的对象来解决内存不足的问题。
- 软引用：如果一个对象只具有软引用，当内存不够时，会回收这些对象的内存，回收后如果还是没有足够的内存，就会抛出OutOfMemoryError异常。Java提供了SoftReference类来实现软引用。
- 弱引用：弱引用比起软引用具有更短的生命周期，垃圾收集器一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存。Java提供了WeakReference类来实现弱引用。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，这就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。一个只具有虚引用的对象，被垃圾收集器回收时会收到一个系统通知，这也是虚引用的主要作用。Java提供了PhantomReference类来实现虚引用。

### 2.2 引用计数算法

引用计数算法的基本思想就是每个对象都有一个引用计数器，当对象在某处被引用的时候，它的引用计数器就加1，引用失效时就减1。当引用计数器中的值变为0，则该对象就不能被使用成了垃圾。

目前主流的Java虚拟机没有选择引用计算算法来标记垃圾，主要原因是引用计算算法无法解决对象之间互相循环引用的问题。

### 2.3 根搜索算法

根搜索算法的基本思想是选的一些对象作为GC Roots，并组成根对象集合，然后从这些GC Roots的对象作为起始点，向下进行搜索，如果目标对象到GC Roots是连接着的，则标记该对象是可达的，如果目标对象是不可达的，则说明对象是可回收的垃圾对象。

可作为GC Roots的对象有以下几种：

Java虚拟机栈中的引用的对象。

本地方法栈中JNI引用的对象。

方法区中运行时常量池引用的对象。

运行中的线程。

由引导类加载器加载的对象

GC控制的对象。

## 3.Java对象在JVM中的生命周期

当Java对象被类加载器加载到虚拟机中后，Java对象在Java虚拟机中有7个阶段。

### 1.创建阶段(Created)

创建阶段的具体步骤为：

- 为对象分配存储空间。
- 构造对象。
- 从超类到子类对static成员进行初始化。
- 递归调用超类的构造方法。
- 调用子类的构造方法。

### 2.应用阶段(In Use)

当对象被创建，并分配给变量赋值，状态就切换到了应用阶段。
这一阶段的对象至少要具有一个强引用，或者显式的使用软引用、弱引用或者虚引用。

### 3.不可见阶段(Invisible)

程序中找不到对象的任何强引用，比如程序的执行已经超出了该对象的作用域。在不可见阶段，对象仍可能被特殊的强引用GC Roots持有着，比如对象被本地方法栈中JNI引用或是被运行中的线程引用等。

### 4.不可达阶段(Unreachable)

程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达。

### 5.收集阶段(Collected)

垃圾收集器已经发现对象不可达，并且垃圾收集器已经准备好要对该对象的内存空间重新进行分配时。这个时候如果该对象重写了finalize方法，则会调用该方法。

### 6.终结阶段(Finalized)

当对象执行完finalize法后仍然处于不可达状态时，或者对象没有重写finalize方法，则该对象进入终结阶段，并等待垃圾收集器回收该对象空间。

### 7.对象空间重新分配阶段(Deallocated)

当垃圾收集器对对象的内存空间进行回收或者再分配时，这个对象就会彻底消失。



