​	多个线程访问同一个资源时需要考虑到线程同步问题，为了保证多线程共享数据的安全性，java语言给我们提供了线程锁，保证同一个时刻只有一个线程处理共享数据。当一个锁被某个线程持有的时候，另一个线程尝试去获取这个锁，就会出现线程阻塞，直到持有锁的线程释放改锁。Java线程同步有多种方法。

## 1. 锁对象

在线程中创建锁对象Lock，调用Lock.lock方法封锁锁对象，其他线程执行时都无法通过lock后的语句，线程被阻塞直到第一个线程释放锁对象，调用Lock.unlock方法释放锁对象。

## 2. 条件对象

线程中的代码执行进入锁后，发现需要满足一个条件才能执行。所以需要一个条件对象来管理哪些已经获得锁对象却不能有用工作的线程。使用方法是在Lock.lock后，调用lock.newCondition方法获取Condition条件对象，在需要条件的代码调用Condition.await方法阻塞当前线程，放弃锁，等待其他线程激活当前线程，否则就产生了死锁现象。当其他线程获取锁，执行代码后调用Condition的signalAll方法去激活所有放弃锁的等待线程。

## 3. Syncchronized关键字

syncchronized关键字自动地提供了锁及相关条件。

### 3.1 syncchronized方法

使用syncchronized关键字修改方法，当某个线程进入同步的方法中时，调用同一实例的该同步方法的所有其他线程都必须等待，当此线程从同步方法返回时，其他线程才可调用。

### 3.2 syncchronzied语句

使用syncchronzied对代码块加锁，当线程进入方法的syncchronzied代码块之后，其他线程调用此方法就无法进入syncchronzied代码块，只有syncchronzied代码执行完成后，其他方法可以调用。object 是对被同步对象的引用变量。

```java
	 synchronized(object){
 
	 }
```

### 3.3 对象锁和类锁

类锁(.clsss)主要是为了区分静态代码的特点，因为静态代码实所有对象实例共用的，对应的syncchronzied来修饰的静态方法的锁也是唯一的，类锁和对象锁是两个不一样的领域，控制者不同的区域，线程获取对象锁的同时也可以获取类锁。

## 4. 死锁

当两个线程循环依赖一对同步对象时，就会发生死锁，例如，假设一个线程进入对象A的监视器，另一个线程进入对象B的监视器。如果A中的线程试图调用B中的同步方法，就会由于监视器被占用而阻塞。如果此时B中的线程也试图调用A中的同步方法，那么也会由于同样的原因而被阻塞。 死锁是一种很难调试的错误，原因有两点：

- 死锁通常很少发生，只有当两个线程恰好以这种方式获取CPU时钟周期时才会发生死锁
- 死锁可能涉及更多的线程以及更多的同步对象

## 5. sleep() 和 wait() 的区别

调用sleep方法的线程不会释放对象锁，而调用wait() 方法会释放对象锁。

