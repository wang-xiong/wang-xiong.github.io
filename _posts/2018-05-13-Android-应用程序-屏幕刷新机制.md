---
layout: post
title: "Android应用程序之屏幕刷新机制"
subtitle: 'Android应用程序学习'
date:       2018-05-13
author: "Wangxiong"
header-style: text
tags:
  - Android
  - Android应用程序
---

一个典型的显示系统包括三个部分：CPU、GPU、display三个部分。CPU计算数据，GPU进一步处理和缓存数据，最后display再将缓存中的屏幕数据显示出来。

常说的Android每隔16.6ms刷新一次屏幕是指：底层以固定的频率，比如每隔16.6ms将buffer里的屏幕数据显示出来，即VSync信号。

Display显示的每一帧画面，CPU代表的就是计算对应帧的画面数据，也叫屏幕数据，也就是在当前帧内容，CPU是在计算下一帧的屏幕画面数据，当屏幕刷新信号VSync到时候，屏幕将CPU计算的数据显示出来，CPU同时收到屏幕的刷新信号，去计算下一帧的屏幕数据。

当我们的app界面没有必要刷新时（比如用户不操作了，当前界面也没有动画），这个时候，我们app是接受不到屏幕的刷新信号的，所以不会让CPU去计算下一帧的画面数据，但是底层会仍然以固定频率来切换每一帧的画面，只是它切换的每一帧画面都是一样的，随意给我感觉屏幕没有刷新。

1. 我们常说的Android每隔16.6ms刷新一次屏幕，其实就是指底层会以这个固定频率来切换每一帧的画面。
2. 这个每一帧的画面也就是我们的app绘制视图树（View树）计算出来的，这个工作是有CPU处理，耗时的长度取决于我们写的代码：布局复不复杂，层次深不深，同一帧内刷新的View数量多不多。
3. CPU绘制视图树来计算下一帧画面数据的工作是在屏幕刷新新信号来的时候开始工作，而这个工作处理完毕后，也就是下一帧的画面数据已经全部计算完毕，也不会立马显示在屏幕上，而是等下一个屏幕刷新的信号过来的时候再交由底层将计算完毕的屏幕画面数据显示出来。
4. 当我们的app界面不刷新时，app就接受不到屏幕的刷新新信号，所以也不会让CPU再去绘制视图树计算画面数据工作，但是底层会任然每个16.6ms切换下一帧的画面，只是这个下一帧画面是个相同的内容。
5. 界面上的任何一个View的刷新请求最终都会走到ViewRootImpl的scheduleTraversals方法里安排一次遍历绘制View树的的任务。
6. scheduleTraversals方法会先过滤掉同一帧的重复调用，在统一帧内只会安排一次遍历Views树的任务，这个任务绘制下个屏幕刷新信号到来时调用performTraversals遍历View树，遍历过程会将所有需要刷新的View进行重绘。
7. 接着scheduleTraversals会向主线程的消息发送一个同步屏障，拦截这个时刻之后的所有同步消息的执行，但是不会拦截异步消息，以此来保证尽可能接受到屏幕刷新信号的第一时间处理遍历View树的工作。
8. 大多数呈现界面显示的都是Activity，但真正承载视图的是一个Window,每个Window都有一个DecorView，我们调用setContentView其实就是将我们的布局添加在已DecorView为根布局的ViewGroup里，构成View树，DecorView的mParent是ViewRootImpl,而每个界面的View刷新，绘制，点击，都是通过ViewRootImpl发起，去DecorView开始遍历View树去分发处理。