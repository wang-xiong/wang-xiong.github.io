---
layout: post
title: "【Java基础】Java线程"
subtitle: 'Java基础回顾复习'
date:       2018-03-23
author: "Wangxiong"
header-style: text
tags:
  - Java
---
Java支持多线程编程，一个进程中可以用多个线程。

## 1. 创建线程

创建线程常用有两种方法：1.实现Runnable接口，2.继承Thread类。

## 2. 主线程

Java程序启动时，会立即开始运行一个线程，这个线程就是程序的主线程，其他子线程都是从主线程中产生的。可以通过Thread.currentThread()方法返回对调用它的线程的引用。

## 3. 线程的状态

线程有多种状态，线程只要获取CPU时间就运行(runnable)，运行的线程可以被挂起(suspended)临时停止线程的活动，挂起的线程可以被恢复(resumed)从停止处恢复执行，当等待资源时，线程会被阻塞(blocked)。在任何时候都可以终止线程，这会立即停止线程的执行，线程一旦终止，就不能再恢复。通过Thread的getState方法可以获取线程的状态。返回的值如下：

| 值            | 状态                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 线程处于新建状态，还没有开始执行                             |
| RUNNABLE      | 线程要么当前正在执行，要么在获取CPU的访问权之后执行          |
| BLOCKED       | 线程因为正在等待需要的锁而挂起执行                           |
| TERMINATED    | 线程已经完成执行                                             |
| TIMED_WAITING | 线程挂起执行一段指定的时间，例如当调用sleep()方法时就会处于这种状态。当调用wait()或join()方法的暂停版时，也会进入这种状态 |
| WAITING       | 线程因为等待某些动作而挂起执行。例如，因为调用非暂停版的wait()或join()方法而等待时，会处于这种状态 |

1. 新建状态: 使用 new 关键字建立一个线程对象后，线程就处于新建状态，线程保持这个状态直到程序 start() 这个线程
2. 就绪状态: 当线程对象调用了 start() 方法之后，线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度
3. 运行状态: 如果就绪状态的线程获取到 CPU 资源，就可以执行 run() 方法，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态
4. 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。阻塞状态可以分为三种：

- 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态
- 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)
- 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态
5. 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态

![java基础线程.jpg](https://upload-images.jianshu.io/upload_images/10547376-99c09e9648a81f3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 4.  线程同步

多个线程访问同一个资源时需要考虑到线程同步问题，为了保证多线程共享数据的安全性，java语言给我们提供了线程锁，保证同一个时刻只有一个线程处理共享数据。当一个锁被某个线程持有的时候，另一个线程尝试去获取这个锁，就会出现线程阻塞，直到持有锁的线程释放改锁。Java线程同步有多种方法。

### 4.1 syncchronized方法

使用syncchronized关键字修改方法，当某个线程进入同步的方法中时，调用同一实例的该同步方法的所有其他线程都必须等待，当此线程从同步方法返回时，其他线程才可调用。

### 4.2 syncchronzied语句

使用syncchronzied对代码块加锁，当线程进入方法的syncchronzied代码块之后，其他线程调用此方法就无法进入syncchronzied代码块，只有syncchronzied代码执行完成后，其他方法可以调用。object 是对被同步对象的引用变量。

```java
	 synchronized(object){
 
	 }
```

### 4.3 死锁

当两个线程循环依赖一对同步对象时，就会发生死锁，例如，假设一个线程进入对象A的监视器，另一个线程进入对象B的监视器。如果A中的线程试图调用B中的同步方法，就会由于监视器被占用而阻塞。如果此时B中的线程也试图调用A中的同步方法，那么也会由于同样的原因而被阻塞。 死锁是一种很难调试的错误，原因有两点：

- 死锁通常很少发生，只有当两个线程恰好以这种方式获取CPU时钟周期时才会发生死锁
- 死锁可能涉及更多的线程以及更多的同步对象



